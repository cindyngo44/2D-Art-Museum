abstract class Algorithms{
  Graph graph;

  void runAlgorithm(){

  }
}
//TODO: Set this.graph to graph being passed in, and create each algorithm
//Output: Painting names in console + how long the algorithm took to run
class BFS extends Algorithms{
  //Print out in console the painting title thoruhg BFS
  BFS(Graph graph){
    this.graph = graph;

  }

    void runAlgorithm(){
      boolean visited[] = new boolean[graph.adjList.size()];      
        int a = 0;
        // create a queue for doing BFS
        Queue<Integer> q = new ArrayDequeue();
 
        // mark the source vertex as discovered
        visited[a] = true;
 
        // enqueue source vertex
        q.add(a);
 
        // loop till queue is empty
        while (!q.isEmpty())
        {
            // dequeue front node and print it
            a = q.poll();
            System.out.print(graph.vertexStorage.get(a).title + " ");
 
            // do for every edge (v, u)
            for (int u: graph.adjList.get(a))
            {
                if (!visited[u])
                {
                    // mark it as discovered and enqueue it
                    visited[u] = true;
                    q.add(u);
                }
            }
        }
        }
  }
  

class DFS extends Algorithms{
    ArrayList<boolean> visited = new ArrayList<boolean>;
    DFS(Graph graph){
      this.graph = graph;
    }

    void runAlgorithm(){

    }
    void DFS(int source){

    }
}
class Dijkstra extends Algorithms{
  Dijkstra(Graph graph){
    this.graph = graph;
  }

    void runAlgorithm(){

  }
}
